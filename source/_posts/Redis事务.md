---
title: Redis事务
date: 2018-12-07 10:09:17
tags: Redis
categories: 数据库
---

Redis事务

![F1oW5V.md.png](https://s1.ax1x.com/2018/12/07/F1oW5V.md.png)

Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断,Redis事务的主要作用就是串联多个命令防止别的命令插队

#### Multi

用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。

这个命令的运行格式如下所示：

#### MULTI

这个命令的返回值是一个简单的字符串，总是OK。

####  EXEC

在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。

当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。

这个命令的运行格式如下所示：

EXEC

这个命令的返回值是一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值。 当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值。

####  DISCARD

清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。

如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。

这个命令的运行格式如下所示：

```
DISCARD
```

这个命令的返回值是一个简单的字符串，总是OK。

#### WATCH

当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。

这个命令的运行格式如下所示：

```
WATCH key [key ...]
```

这个命令的返回值是一个简单的字符串，总是OK。

对于每个键来说，时间复杂度总是O(1)。

####  UNWATCH

清除所有先前为一个事务监控的键。

如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。

这个命令的运行格式如下所示：

```
UNWATCH
```

这个命令的返回值是一个简单的字符串，总是OK。

时间复杂度总是O(1)。

#### 总结


从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，至到输入Exec后，Redis会将之前的命令队列中的命令依次执行。	

![F1oTKJ.md.png](https://s1.ax1x.com/2018/12/07/F1oTKJ.md.png)

组队的过程中可以通过discard来放弃组队。 

### 事务的错误处理

如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。

![F1T9rd.md.png](https://s1.ax1x.com/2018/12/07/F1T9rd.md.png)

### Redis 事务的三特性

#### 单独的隔离操作

事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断

#### 没有隔离级别的概念

队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 

#### 不保证原子性

Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 



### 为什么要做成事务

应用场景:抢购

两个请求

一个请求想给金额减8000

一个请求想给金额减5000

一个请求想给金额减1000

![F1TKqs.md.png](https://s1.ax1x.com/2018/12/07/F1TKqs.md.png)

这样的话即使在用户卡里没有金额的情况下仍旧可以进行支付。为了解决这个问题我们在Redis中使用到了锁的机制

#### 悲观锁

悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

![F1HmHs.md.png](https://s1.ax1x.com/2018/12/07/F1HmHs.md.png)

#### 乐观锁

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。

![F1HUER.md.png](https://s1.ax1x.com/2018/12/07/F1HUER.md.png)

#### Rediss事务 -------秒杀

 解决计数器和人员记录的事务操作

![F1HyKe.md.png](https://s1.ax1x.com/2018/12/07/F1HyKe.md.png)

#### 超卖问题

![F1HRUI.md.png](https://s1.ax1x.com/2018/12/07/F1HRUI.md.png)

#### 乐观锁

![F1HvGV.md.png](https://s1.ax1x.com/2018/12/07/F1HvGV.md.png)

#### lua脚本

![F1HzxU.png](https://s1.ax1x.com/2018/12/07/F1HzxU.png)